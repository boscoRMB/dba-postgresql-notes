Query Processing

•概述PostgreSQL中的查询处理
•单表查询的最佳计划所遵循的步骤
•估算成本和创建计划树的过程
•三种连接方法：嵌套循环、合并和哈希连接
•创建多表查询的计划树的过程

1. 解析器 parser
  解析器从纯文本的SQL语句生成解析树。
2. 分析仪/分析器 analyzer
  分析器/分析器对解析树执行语义分析并生成查询树。
3. 重写器 rewriter
  重写器使用存储在规则系统中的规则（如果存在此类规则）转换查询树。
4. 规划器 Planner
  计划者从查询树生成可以最有效地执行的计划树。 --- 消耗资源最大，选择执行计划的好坏，直接决定执行时长
5. 执行器 executor
  执行器通过按计划树创建的顺序访问表和索引来执行查询。

parse tree:
解析器生成一个解析树，后续子系统可以从纯文本的SQL语句中读取该树

query tree:
分析器/分析器对解析器生成的解析树运行语义分析，并生成查询树。

Rewriter ???
重写器是实现规则系统的系统，必要时根据pg_rules系统目录中存储的规则转换查询树。

PostgreSQL中的视图是通过规则系统实现的。通过“创建视图”命令定义视图时，将自动生成相应的规则并将其存储在目录中。
CREATE VIEW employees_list
AS SELECT e.id, e.name, d.nameAS department
FROM employees AS e, departments AS d
WHERE e.department_id= d.id;
假设已经定义了以下视图并且相应的规则存储在pg_rules系统目录中

Planner and Executor
规划器从重写器接收查询树，并生成（查询）计划树，执行者可以最有效地处理该树。。
pg_hint_plan插件-- oracle 可以explicitly use hint to let oracle use that execution plan, but postgres does not support it, and you need the plugin pg_hint_plan
PostgreSQL不支持SQL中的计划器提示，并且永远不会支持它。如果要在查询中使用提示，需要引用pg_hint_plan扩展插件。


--------------------------------------execution plan -------------------
explain show sql execution plan, like other rdbms
testdb=# EXPLAIN SELECT * FROM tbl_aWHERE id < 300 ORDER BY data;
Sort (cost=182.34..183.09 rows=300 width=8)
  Sort Key: data
  -> SeqScan on tbl_a(cost=0.00..170.00 rows=300 width=8)
    Filter: (id < 300)
(4 rows)
只是执行计划，并不是真的执行
如何看： 从下往上，从最向右缩进的看起
filter: filter 方式
SeqScan: 全表扫描
cost:访问成本
rows:返回行数
sort key: 排序的列
sort cost: 排序成本

执行器通过后端进程执行，产生执行计划
把所需的数据块读到数据缓冲区： database cluster to buffer manager
把结果返回给执行器： buffer manager to executor
执行器： pg会分配工作内存（work_mem) 给执行器，如果数据量太大，工作内存（work_mem)不够的话，就会产生临时文件（Temporary file），用他来存储中间的结果，最后再删掉。


---------------------------------------单表查询成本估算-------------------------
单表查询中的成本估算
•优化基于成本。成本是无量纲值，这些不是绝对的绩效指标，而是比较运营相对绩效的指标。
•执行者执行的所有操作都具有相应的成本函数。
•三种成本：启动、运行和总计。总成本是启动和运行成本的总和
  1.启动成本是在获取第一个行之前花费的成本。例如，索引扫描节点的启动成本是读取索引页面以访问目标表中的第一个元组的成本。
  2.运行成本是获取所有行的成本。
  3.总成本是启动和运行成本的成本之和。
sample:
testdb=# EXPLAIN SELECT * FROM tbl;
QUERY PLAN
---------------------------------------------------------
SeqScan on tbl(cost=0.00..145.00 rows=10000 width=8)
在第4行中，命令显示有关顺序扫描的信息。在“成本”部分中，有两个值：0.00和145.00。在这种情况下，启动和总成本分别为0.00和145.00。



--------------------------------单表查询成本估算之顺序扫描(全表扫描）----------------------------
Sequential Scan成本计算
顺序扫描的成本由cost_seqscan（）函数估算。我们将探讨如何估算以下查询的顺序扫描成本。
testdb=# SELECT * FROM tblWHERE id < 8000;
在顺序扫描中，启动成本等于0，运行成本由以下等式定义：
‘run cost’=‘cpurun cost’+‘diskrun cost’
=(cpu_tuple_cost（访问一行数据代价）+cpu_operator_cost（cpu操作成本）)×𝑁tuple+seq_page_cost（访问数据块的代价）×𝑁page（数据块数量）

查询表的块数（page）和行数（tuple）：
testdb=# SELECT relpages, reltuples FROM pg_class WHERE relname= 'tbl';
relpages| reltuples
----------+-----------
45 | 10000
𝑁tuple= 10000 （1）
𝑁page=45（2）
根据（1，2）得出
‘runcost’=(0.01+0.0025)×10000+1.0×45=170.0
总成本：
‘totalcost’=0.0+170.0=170

怎么找出cpu_tuple_cost、cpu_operator_cost、seq_page_cost 呢？
\d pg_settings
test=# select name, setting from pg_settings where name like '%cost%';
             name             | setting 
------------------------------+---------
 autovacuum_vacuum_cost_delay | 2
 autovacuum_vacuum_cost_limit | -1
 cpu_index_tuple_cost         | 0.005
 cpu_operator_cost            | 0.0025
 cpu_tuple_cost               | 0.01
 jit_above_cost               | 100000
 jit_inline_above_cost        | 500000
 jit_optimize_above_cost      | 500000
 parallel_setup_cost          | 1000
 parallel_tuple_cost          | 0.1
 random_page_cost             | 4
 seq_page_cost                | 1
 vacuum_cost_delay            | 0
 vacuum_cost_limit            | 200
 vacuum_cost_page_dirty       | 20
 vacuum_cost_page_hit         | 1
 vacuum_cost_page_miss        | 10
(17 rows)
(PS: tunning does not mean tuning thses parameters)


-------------------------------------单表查询成本估算之索引扫描----------------------------------
3.2.1. Index Scan成本估算
计算下面的查询语句通过索引访问成本计算：
create index tbl_data_idx on tbl(data);
testdb=# SELECT id, data FROM tblWHERE data < 240;
3.2.2.1.先查询索引的行数和页数𝑁𝑖𝑛𝑑𝑒𝑥,𝑡𝑢𝑝𝑙𝑒𝑁index,𝑝𝑎𝑔𝑒
testdb=# SELECT relpages, reltuplesFROM pg_classWHERE relname= 'tbl_data_idx';
relpages| reltuples
----------+-----------
30 | 10000
𝑁index,𝑝𝑎𝑔𝑒=30（3）
𝑁𝑖𝑛𝑑𝑒𝑥,𝑡𝑢𝑝𝑙𝑒=10000（4）

test=# explain select * from tbl where data<240;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Index Scan using tbl_data_ind on tbl  (cost=0.29..13.47 rows=239 width=8)
   Index Cond: (data < 240)
(2 rows)
启动成本：0.29
总成本：13.47

3.2.2. Index Scan 成本估算
3.2.2.1.启动成本计算公式
‘start-upcost’={ceil(𝑙𝑜𝑔2(𝑁𝑖𝑛𝑑𝑒𝑥,𝑡𝑢𝑝𝑙𝑒))+(𝐻𝑖𝑛𝑑𝑒𝑥+1)×50}×cpu_operator_cost
𝐻𝑖𝑛𝑑𝑒𝑥指的是索引的高度
启动成本计算结果：
根据第（3）𝑁𝑖𝑛𝑑𝑒𝑥,𝑡𝑢𝑝𝑙𝑒=10000，𝐻𝑖𝑛𝑑𝑒𝑥=1 和cpu_operator_cost= 0.0025 (by default)
得出如下结果：
‘start-upcost’={ceil(𝑙𝑜𝑔2(10000))+(1+1)×50}×0.0025=0.285（5）

Index Scan成本估算
3.2.2.2.运行成本计算公式 -- 通过索引访问基表的代价
索引扫描的运行成本是表和索引的cpu成本和IO（输入/输出）成本之和
‘runcost’=(‘index cpu cost’+‘table cpu cost’)+(‘index IO cost’+‘table IO cost’)
前三个成本（即索引cpu成本，表cpu成本和索引IO成本）计算公式：
‘indexcpucost’=Selectivity×𝑁index,𝑡𝑢𝑝𝑙𝑒×(cpu_index_tuple_cost+qual_op_cost),
‘tablecpucost’=Selectivity×𝑁𝑡𝑢𝑝𝑙𝑒×cpu_tuple_cost, ‘
indexIOcost’=ceil(Selectivity×𝑁𝑖𝑛𝑑𝑒𝑥,𝑝𝑎𝑔𝑒)×random_page_cost,

Selectivity 可选性
表的每一列的MCV(Most Common Value)作为一对most_common_vals和most_common_freqs的列存储在pg_stats视图中。
•most_common_vals是统计MCVs列表的列。
•most_common_freqs是统计mcv的频率列。
让我们考虑下面的查询，它有一个WHERE子句，“contain=”Asia'：
testdb=# SELECT * FROM countries WHERE continent = 'Asia';
test=# select most_common_vals, most_common_freqs from pg_stats where tablename='countries' and attname='continent';
                       most_common_vals                       |                          most_common_fre
qs                           
--------------------------------------------------------------+-----------------------------------------
-----------------------------
 {Africa,Europe,Asia,"North America",Oceania,"South America"} | {0.2746114,0.24352331,0.22797927,0.11917
0986,0.07253886,0.062176164}
(1 row)
--选Asia的列值的频率是0.2279也是他的选择性selectivity是0.2279
--mcv 不适用场景，如大量数据不重复，tbl为例

•histogram_bounds
是一个值列表，用于将列的值分成大致相等的总体组
test=# select histogram_bounds from pg_stats where tablename='tbl' and attname='data';
                                                                                        
                                histogram_bounds                                                        
                                                                                                        
                                                                                 
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------
 {1,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200
,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,430
0,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,64
00,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8
500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000}
(1 row)

•Buckets and histogram_bounds.
--一万行数据分成100个bucket, 
-- bucket_0   bucket_1    bucket_2
-- hb[0]      hb[1]       hb[2] -- 对应bucket的最小值
-- 1          100         200  -- 


•Selectivity
WHERE data<240 计算选择性
Selectivity= 2+(240−hb[2])/(hb[3]−hb[2])100= 2+(240−200)/(300−200)100= 2+40/100100=0.024（6）

Index Scan成本估算
‘indexcpucost’=Selectivity×𝑁index,𝑡𝑢𝑝𝑙𝑒×(cpu_index_tuple_cost+qual_op_cost),
‘tablecpucost’=Selectivity×𝑁𝑡𝑢𝑝𝑙𝑒×cpu_tuple_cost, ‘
indexIOcost’=ceil(Selectivity×𝑁𝑖𝑛𝑑𝑒𝑥,𝑝𝑎𝑔𝑒)×random_page_cost,
前三个成本（即索引cpu成本，表cpu成本和索引IO成本）计算公式：
根据（1，3，4，6）索引cpu成本、表cpu成本和索引IO成本计算结果：
‘indexcpucost’=0.024×10000×(0.005+0.0025)=1.8,（7）
‘tablecpucost’=0.024×10000×0.01=2.4,（8）
‘indexIOcost’=ceil(0.024×30)×4.0=4.0.（9）
Index Scan成本估算
table IO cost计算公式：
tableIOcost=max_IO_cost+indexCorrelation2×(min_IO_cost−max_IO_cost).

Index Scan成本估算
min_IO_cost计算公式与结果：
min_IO_cost=1×random_page_cost（最好情况一下就中了）+(ceil(Selectivity×𝑁page)-1)×seq_page_cost
min_IO_cost=1×4.0+(ceil(0.024×45))−1)×1.0=5.0（11）
max_IO_cost计算公式与结果：
max_IO_cost= 𝑁page×random_page_cost（随机访问一个数据块的开销）
--最坏情况，访问历遍45个数据块，到最后才访问到对的数据块
根据第（2）𝑁page=45 得出如下结果：
max_IO_cost=45×4.0=180.0（10）

indexCorrelation
indexCorrelation=1.0 （12）
根据（10，11，12）得出：
‘tableIOcost’=180.0+1.02×(5.0−180.0)=5.0（13）
根据（7，8，9，13）得出索引访问总成本：
‘runcost’=(1.8+2.4)+(4.0+5.0)=13.2 （14）  -- ‘runcost’=(‘index cpu cost’+‘table cpu cost’)+(‘index IO cost’+‘table IO cost’)

列值相同的行存放的比较集中，i/o成本最低
比如select * from employee where name ='cuug' 
返回100 rows
然后这100 rows刚好存放在两个pages上面，就会i\o cost low: 这种情况就是用索引好
相反如果100 rows在100 个pages上面，i\o cost max： 这种情况用full table scan,因为索引访问也需要代价，索引访问完还要数据访问，还不如直接全表扫描



test=# \d tbl_corr
               Table "public.tbl_corr"
  Column  |  Type   | Collation | Nullable | Default 
----------+---------+-----------+----------+---------
 col      | text    |           |          | 
 col_asc  | integer |           |          | 
 col_desc | integer |           |          | 
 col_rand | integer |           |          | 
 data     | text    |           |          | 
Indexes:
    "tbl_corr_asc_idx" btree (col_asc)
    "tbl_corr_desc_idx" btree (col_desc)
    "tbl_corr_rand_idx" btree (col_rand)


test=# analyze tbl_corr;
ANALYZE
test=# SELECT tablename,attname, correlation FROM pg_stats WHERE tablename= 'tbl_corr';
 tablename | attname  | correlation 
-----------+----------+-------------
 tbl_corr  | col      |  0.07692308
 tbl_corr  | col_asc  |           1
 tbl_corr  | col_desc |          -1
 tbl_corr  | col_rand |  0.12587413
 tbl_corr  | data     |            
(5 rows)

testdb=# SELECT * FROM tbl_corr WHERE col_asc BETWEEN 2 AND 4;
因为正相关，2-4都在同一个pages上面，所以会应index scan
testdb=# SELECT * FROM tbl_corr WHERE col_rand BETWEEN 2 AND 4;
因为相关性低，2，3，4三个tuples刚好在3个pages上面，所以避免重复高i/o，会用full table scan


------------------------------seq_page_costand random_page_cost相关参数配置------------------------------------------
大部分情况参数是不用修改的，但是有些可以根据实际情况修改
HDD硬盘：
seq_page_cost=1.0
random_page_cost=4.0
SSD硬盘：
seq_page_cost=1.0
random_page_cost=1.0


---------------------------------------单表查询成本估算之排序--------------------------------------------------
3.2.3. Sort

成本估算公式：
O(𝑁𝑠𝑜𝑟𝑡×𝑙𝑜𝑔2(𝑁𝑠𝑜𝑟𝑡))
估算以下查询语句排序成本：
testdb=# SELECT id, data FROM tblWHERE data < 240 ORDER BY id;

start-up成本估算公式：
‘start-upcost’=C+comparison_cost×𝑁sort×log2(𝑁sort)
根据：
C=上次索引扫描的总成本=13.485
comparison_cost=2×cpu_operator_cost=2×0.0025
得出：
‘start-upcost’=13.485+(2×0.0025)×240.0×log2(240.0)=22.973
‘runcost’=cpu_operator_cost×𝑁sort=0.0025×240=0.6
‘totalcost’=22.973+0.6=23.573

是不是建了索引，就不用排序呢？
例子
test=# explain select * from tbl where data<240 order by id;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort  (cost=22.91..23.51 rows=239 width=8)
   Sort Key: id
   ->  Index Scan using tbl_data_ind on tbl  (cost=0.29..13.47 rows=239 width=8)
         Index Cond: (data < 240)
(4 rows)
这里面id是primary key, 它是有索引的，但是为什么还有sorting cost呢？
because data was filter by where condition, 提取出来的数据，id 列的index已经失效了，因为不一定是按id顺序
如果：
test=# explain select * from tbl where data<240 order by data;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Index Scan using tbl_data_ind on tbl  (cost=0.29..13.47 rows=239 width=8)
   Index Cond: (data < 240)
(2 rows)
索引提取的数据本来就按照data index order过了，所以没有sorting cost
如果：
test=# explain select * from tbl where data>240 order by data;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Index Scan using tbl_data_ind on tbl  (cost=0.29..338.09 rows=9760 width=8)
   Index Cond: (data > 240)
(2 rows)
原本全表扫描变成索引扫描，省去了排序，但是因为selectivity很大，所以索引扫描相当于全表所有pages扫一遍，所以cost 很高，比不filter还高
不加filter: Seq Scan on tbl  (cost=0.00..170.00 rows=9760 width=8)
但是如果本身没有index，然后又必须执行排序sort的话
test=# create table tbl2 as select * from tbl;
SELECT 10000
test=# \d tbl2
                Table "public.tbl2"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 id     | integer |           |          | 
 data   | integer |           |          | 

test=# explain select * from tbl2 order by data;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=809.39..834.39 rows=10000 width=8)
   Sort Key: data
   ->  Seq Scan on tbl2  (cost=0.00..145.00 rows=10000 width=8)
(3 rows)

test=# 
可见，在没有index的帮助下，sorting cost is huge. 
综上所诉，如果排序是必须的话，build index in sorting condition will help except the where condition is different from the order by condition. 


------------------------------------------单表查询之创建计划树--------------------------------------------------
3.3. 为单表查询创建计划树

PostgreSQL中的计划器执行三个步骤：
•进行预处理。
•通过估计所有可能的访问路径的成本，获得最便宜的访问路径。
•从最便宜的路径创建计划树

3.3.1. Preprocessing
PostgreSQL中的计划器执行三个步骤：
•简化目标列表、限制子句等。
•规范化布尔表达式。
•展平AND/OR 表达式

3.3.2.获得最便宜的访问路径
.
1、创建RelOptInfo结构来存储访问路径和相应的开销。
2、估计所有可能的访问路径的成本，并将访问路径添加到RelOptInfo结构中。
创建路径，估计顺序扫描的成本，并将估计的成本写入路径。然后，将路径添加到RelOptInfo结构的路径列表中。
如果存在与目标表相关的索引，则创建索引访问路径，估算所有索引扫描成本，并将估算成本写入路径。然后，将索引路径添加到路径列表中。
如果位图扫描可以完成，则创建位图扫描路径，估计所有位图扫描成本，并将估计成本写入路径。然后，位图扫描路径被添加到路径列表中。
3、获取RelOptInfo结构的路径列表中最便宜的访问路径。
4、如有必要，估算LIMIT, ORDER BY 和ARREGISFDD等成本

3.3.2.1. Example 1
首先，我们探索一个没有索引的简单单表查询；这个查询同时包含WHERE和ORDER BY子句。





------------------------------------------单表查询之执行器执行----------------------------------
3.4. How the Executor Performs
.
testdb=# EXPLAIN SELECT * FROM tbl_1WHERE id < 300 ORDER BY data;
QUERY PLAN
---------------------------------------------------------------
Sort (cost=182.34..183.09 rows=300 width=8)
Sort Key: data
-> SeqScan on tbl_1(cost=0.00..170.00 rows=300 width=8)
Filter: (id < 300)
(4 rows)

-----------------------------------------Temporary Files-------------------------------------------------------
test=# create table tbl_big (id int primary key, data int);
CREATE TABLE
test=# insert into tbl_big select generate_series(1,25000000), generate_series(1,25000000);

test=# explain select * from tbl_big;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Seq Scan on tbl_big  (cost=0.00..360621.20 rows=25000120 width=8)
(1 row)

test=# explain select * from tbl_big order by data;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Merge  (cost=1714817.42..4145554.42 rows=20833434 width=8)
   Workers Planned: 2
   ->  Sort  (cost=1713817.39..1739859.19 rows=10416717 width=8)
         Sort Key: data
         ->  Parallel Seq Scan on tbl_big  (cost=0.00..214787.17 rows=10416717 width=8)
(5 rows)

test=# explain analyze select * from tbl_big order by data;
                                                                 QUERY PLAN                             
                                    
--------------------------------------------------------------------------------------------------------
------------------------------------
 Gather Merge  (cost=1714785.68..4145479.51 rows=20833064 width=8) (actual time=20660.819..31933.470 row
s=25000000 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Sort  (cost=1713785.65..1739826.98 rows=10416532 width=8) (actual time=20365.803..22119.705 rows=
8333333 loops=3)
         Sort Key: data
         Sort Method: external merge  Disk: 145904kB
         Worker 0:  Sort Method: external merge  Disk: 146784kB
         Worker 1:  Sort Method: external merge  Disk: 147760kB
         ->  Parallel Seq Scan on tbl_big  (cost=0.00..214785.33 rows=10416532 width=8) (actual time=0.0
97..13722.305 rows=8333333 loops=3)
 Planning Time: 1.051 ms
 Execution Time: 33497.984 ms
(11 rows)
如果你发现你的临时文件产生比较多，可能你排序的临时文件太多了，那么可能你的work_mem太低了，需要调优

临时文件是在base/pg_tmp子目录中临时创建的，命名方法如下所示。
{"pgsql_tmp"} + {PIDof the postgresprocess which creates the file} . {sequencialnumber from 0}
$ ls-la /usr/local/pgsql/data/base/pgsql_tmp*
-rw-------1 postgrespostgres10240000 12 4 14:18 pgsql_tmp8903.5
NOTES: New version of POSTGRESQL
The temporary files that get created in base/pgsql_tmp during query execution will get deleted when the query is done

多表查询之连接方式
3.5. Join Operations
.
三种连接方式：
•nested loop join
•merge join
•hash join
支持所有join操作：
•NATURAL INNER JOIN
•INNER JOIN
•LEFT/RIGHT OUTER JOIN
•FULL OUTER JOIN
